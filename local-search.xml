<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++项目第一章笔记2</title>
    <link href="/2022/07/11/C-%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B02/"/>
    <url>/2022/07/11/C-%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="C-项目第一章：Linux基础编程"><a href="#C-项目第一章：Linux基础编程" class="headerlink" title="C++项目第一章：Linux基础编程"></a>C++项目第一章：Linux基础编程</h1><h2 id="2、静态库制作及使用"><a href="#2、静态库制作及使用" class="headerlink" title="2、静态库制作及使用"></a>2、静态库制作及使用</h2><p>静态库：指的是在程序的链接阶段被复制到程序中。</p><p><strong>写静态库的好处：</strong></p><ul><li><p>代码保密；C++反编译解密程度比较低</p></li><li><p>方便部署和分发</p></li></ul><p><strong>静态库的制作方法：</strong></p><ul><li><p>命名规则：libxxx.a</p></li><li><p>gcc -c(编译但不链接)获得 .o 文件，然后将 .o 文件使用程序 ar 文件打包</p></li><li><p>命令：ar rcs libxxx.a xx.o xx.o，从而生成libxxx.a文件</p></li></ul><p><strong>静态库的使用方法：</strong></p><ul><li>在要编译的文件中，使用 -L 和 -l 以及 -I 指令来搜索对应文件夹下的库的路径和名称，正确编译文件。</li></ul><h2 id="3、动态库制作及使用"><a href="#3、动态库制作及使用" class="headerlink" title="3、动态库制作及使用"></a>3、动态库制作及使用</h2><p>动态库：在程序运行阶段载入内存，动态链接到程序中，并不占用资源，只有用到某个库的时候才会去加载。</p><p><strong>动态库的制作方法：</strong></p><ul><li><p>命名规则：</p><ul><li><p>在 linux 中为 libxxx.so，是一个可执行的文件</p><ul><li><p>lib：前缀（固定）</p></li><li><p>xxx：库的名字，自己起</p></li><li><p>.so：后缀（固定）</p></li></ul></li><li><p>在Windows中为：libxxx.dll</p></li></ul></li><li><p>制作过程：</p><ul><li><p>gcc得到 .o 文件，要加关键字 -fpic 得到与位置无关的代码</p><ul><li><p>gcc -c -fpic a.c b.c</p></li><li><p>再使用gcc由 .o 文件得到动态库</p><ul><li>gcc -shared a.o b.o -o libxxx.so</li></ul></li></ul></li></ul></li></ul><p><strong>动态库加载失败的原因：</strong></p><p>动态库是再linux下的一个可执行文件，只有在程序运行时，动态库会加载到内存中，动态库的装载在程序中相较于静态库，整个执行的过程更加复杂了，因此稍不注意，就容易加载失败，失败原因如下：</p><ul><li><p>动态库和头文件都需要打包给用户</p></li><li><p>编译时需要指明动态库的绝对路径</p></li><li><p>动态库没有写入内存中，程序运行时，找不到动态库</p></li><li><p>动态载入器来获取绝对路径，对于elf格式的可执行程序，由 ld-linux.so来完成，搜索先后路径如下：</p><ul><li>DT_RPATH段——&gt;环境变量 LD_LIBRARY_PATH——&gt;&#x2F;etc&#x2F;ld.so.cache文件列表——&gt;&#x2F;lib&#x2F;, &#x2F;user&#x2F;lib。</li></ul></li></ul><p><strong>找不到动态库的解决办法：</strong></p><ul><li><p>在终端中，将编译好的动态库的路径，直接加入到系统的LD-LIBRARY_PATH环境变量中，即可解决</p><ul><li><p>命令为：export LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:xxx&#x2F;xxx&#x2F;xx</p></li><li><p>缺点是，该操作为临时性的，重新打开终端即失效。</p><ul><li><p>永久用户级配置：配置 .bashrc 文件，然后直接插入配置LD_LIBRARY_PATH的动态库路径。</p><ul><li>配置完成后，在终端home中输入：. .bashrc&#x2F;source .bashrc</li></ul></li><li><p>永久系统级别的配置：在etc&#x2F;profile目录下配置LD_LIBRARY_PATH的动态库路径。</p><ul><li>配置完成后，在终端home中输入：source &#x2F;etc&#x2F;profile</li></ul></li></ul></li></ul></li><li><p>间接修改&#x2F;etc&#x2F;ld.so.cache文件列表（无权限直接打开），找&#x2F;etc&#x2F;ld.so.config文件，直接加入动态库的路径，并使用命令：sudo ldconfig更新。</p></li></ul><h2 id="4、静态库和动态库的对比"><a href="#4、静态库和动态库的对比" class="headerlink" title="4、静态库和动态库的对比"></a>4、静态库和动态库的对比</h2><p><strong>静态库的制作过程：</strong></p><p><img src="https://s2.loli.net/2022/07/13/JcWn9Mahuk8T3bL.png" alt="2.png"></p><p><strong>动态库的制作过程：</strong></p><p><img src="https://s2.loli.net/2022/07/13/fbyS3Ap7VxJBma9.png" alt="3.png"></p><p><strong>静态库的优缺点：</strong></p><ul><li><p>优点：</p><ul><li><p>静态库被打包到应用程序中加载速度快</p></li><li><p>发布程序无需提供静态库，移植方便</p></li></ul></li><li><p>缺点：</p><ul><li><p>消耗系统资源，浪费内存</p></li><li><p>更新、部署、发布麻烦，需重新编译等。</p></li></ul></li></ul><p><strong>动态库的优缺点：</strong></p><ul><li><p>优点：</p><ul><li><p>可以实现进程间资源共享</p></li><li><p>更新、部署、发布简单</p></li><li><p>可以控制何时加载动态库</p></li></ul></li><li><p>缺点：</p><ul><li><p>加载速度比静态库慢</p></li><li><p>发布程序时需要提供依赖的动态库</p></li></ul></li></ul><p>总的来说，</p><p><strong>从产品角度出发</strong>，发布的算法库或功能库尽量使用动态库，这样方便更新和升级，不必重新编译整个可执行文件。</p><p><strong>从函数库集成的角度</strong>，若要将发布的所有子库（不止一个）集成为一个动态库向外提供接口，那么就需要将所有子库编译为静态库，这样所有子库就可以全部编译进目标动态库中，由最终的一个集成库向外提供功能。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++项目第一章笔记</title>
    <link href="/2022/07/11/C-%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/11/C-%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-项目第一章：Linux基础编程"><a href="#C-项目第一章：Linux基础编程" class="headerlink" title="C++项目第一章：Linux基础编程"></a>C++项目第一章：Linux基础编程</h1><h2 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h2><ul><li>Linux虚拟机<ul><li><p>安装VMware Tools，可以在主机和虚拟机之间拖拽文件</p></li><li><p>XSHELL（用于远程登录Linux系统）、XFTP（用于远程Linux和Windows文件的传输）</p></li><li><p>vscode（可在vscode配置rsa公钥，免密码登录，进行主要的代码编写）</p></li></ul></li></ul><p>问题1：无法连接linux，可以在网络适配器设置当中，将</p><p><em>VMware Network Adapter VMnet1</em>和<em>VMware Network Adapter VMnet8</em>禁用再重启</p><ul><li>GCC安装及主要使用方法<ul><li><p>GCC编译流程<br>  <img src="https://s2.loli.net/2022/07/11/qGVbsg9Hd2eSx4N.png" alt="1.png"></p></li><li><p>GCC各个命令的作用</p></li></ul></li></ul><table><thead><tr><th align="center">命令</th><th align="center">作用介绍</th></tr></thead><tbody><tr><td align="center">-E</td><td align="center">预处理指定的源文件，不进行编译</td></tr><tr><td align="center">-s</td><td align="center">编译指定的源文件，但不进行汇编</td></tr><tr><td align="center">-c</td><td align="center">编译、汇编指定的源文件，但不进行链接</td></tr><tr><td align="center">-o [file1] [file2] &#x2F; [file2] -o [file1]</td><td align="center">将文件file2编译成可执行文件file1</td></tr><tr><td align="center">-I</td><td align="center">指定 include包含文件的搜索目录</td></tr><tr><td align="center">-g</td><td align="center">在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td align="center">-D</td><td align="center">在程序编译的时候，指定一个宏</td></tr><tr><td align="center">-w</td><td align="center">不生成任何警告信息</td></tr></tbody></table><table><thead><tr><th align="center">gcc编译选项</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-Wall</td><td align="center">生成所有警告信息</td></tr><tr><td align="center">-On</td><td align="center">n的取值范围：0~3.编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td align="center">-l</td><td align="center">在程序编译的时候，指定使用的库</td></tr><tr><td align="center">-L</td><td align="center">指定编译时候，搜索的库的路径</td></tr><tr><td align="center">-fPIC&#x2F;fpic</td><td align="center">生成与位置无关的代码</td></tr><tr><td align="center">-shared</td><td align="center">生成共享目标文件，通常用在建立共享库上</td></tr><tr><td align="center">-std</td><td align="center">指定C方言，如：-std&#x3D;c99，gcc默认的方言为 GUN C</td></tr></tbody></table><ul><li><p>gcc的命令</p><ul><li><p>gcc编译格式：gcc xx.c -o 生成的可执行文件名称</p></li><li><p>-E：预编译</p></li><li><p>-S：生成汇编代码</p></li></ul></li><li><p>一般来说，gcc用来编译C语言，g++用来编译C++语言</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2022/06/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2022/06/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章！！！</p><img src="/2022/06/28/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/1.jpg" class="" title="This is an example image">]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/28/hello-world/"/>
    <url>/2022/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
